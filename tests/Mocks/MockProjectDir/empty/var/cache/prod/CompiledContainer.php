<?php
/**
 * This class has been auto-generated by PHP-DI.
 */
class CompiledContainer extends DI\CompiledContainer{
    const METHOD_MAPPING = array (
  'Kuick\\App\\Router\\RouteMatcher' => 'get1',
  'Psr\\Log\\LoggerInterface' => 'get2',
  'kuick.app.project.dir' => 'get3',
);

    protected function get1()
    {
        return $this->resolveFactory(static function (\Psr\Container\ContainerInterface $container): \Kuick\App\Router\RouteMatcher {
            $logger = $container->get(\Psr\Log\LoggerInterface::class);
            $projectDir = $container->get(\Kuick\App\AppDIContainerBuilder::PROJECT_DIR_CONFIGURATION_KEY);
            $cache = new \Kuick\Cache\FileCache($projectDir . \Kuick\App\AppDIContainerBuilder::CACHE_PATH);
            $cachedRoutes = $cache->get(\Kuick\App\DIFactories\BuildRouteMatcher::CACHE_KEY);
            $routes = [];
            if (\Kuick\App\KernelAbstract::ENV_PROD == getenv(\Kuick\App\KernelAbstract::APP_ENV) && null !== $cachedRoutes) {
                $logger->debug('Routes loaded from cache');
                $routes = $cachedRoutes;
            }
            if (empty($routes)) {
                //@TODO: extract route parsing to the external class
                //app config (normal priority)
                foreach (glob($projectDir . '/config/*.routes.php') as $routeFile) {
                    $routes = array_merge($routes, include $routeFile);
                }
                //validating routes
                //decorating routes with available controller arguments
                foreach ($routes as $routeKey => $route) {
                    (new \Kuick\App\Router\RouteValidator())($route);
                    $routes[$routeKey]['arguments'][$route['controller']] = (new \Kuick\App\Router\ClassInvokeArgumentReflector())($route['controller']);
                    if (!isset($route['guards'])) {
                        continue;
                    }
                    foreach ($route['guards'] as $guard) {
                        $routes[$routeKey]['arguments'][$guard] = (new \Kuick\App\Router\ClassInvokeArgumentReflector())($guard);
                    }
                }
                $cache->set(\Kuick\App\DIFactories\BuildRouteMatcher::CACHE_KEY, $routes);
                $logger->notice('Routes analyzed, cache written');
            }
            return (new \Kuick\App\Router\RouteMatcher($container->get(\Psr\Log\LoggerInterface::class)))->setRoutes($routes);
        }, 'Kuick\\App\\Router\\RouteMatcher');
    }

    protected function get2()
    {
        return $this->resolveFactory(static function (\Psr\Container\ContainerInterface $container): \Psr\Log\LoggerInterface {
            $logger = new \Monolog\Logger($container->get('kuick.app.name'));
            $logger->useMicrosecondTimestamps((bool) $container->get('kuick.app.monolog.usemicroseconds'));
            $logger->setTimezone(new \DateTimeZone($container->get('kuick.app.timezone')));
            $handlers = $container->get('kuick.app.monolog.handlers');
            $defaultLevel = $container->get('kuick.app.monolog.level') ?? \Psr\Log\LogLevel::WARNING;
            !is_array($handlers) && throw new \Kuick\App\AppException('Logger handlers are invalid, should be an array');
            foreach ($handlers as $handler) {
                $type = $handler['type'] ?? throw new \Kuick\App\AppException('Logger handler type not defined');
                $level = $handler['level'] ?? $defaultLevel;
                //@TODO: extract handler factory to the different class and add missing types
                switch ($type) {
                    case 'fingersCrossed':
                        //@TODO: add more nested handler options
                        $nestedHandler = new \Monolog\Handler\StreamHandler($handler['nestedPath'] ?? 'php://stdout', $handler['nestedLevel'] ?? 'debug');
                        $logger->pushHandler(new \Monolog\Handler\FingersCrossedHandler($nestedHandler, $level));
                        break;
                    case 'firePHP':
                        $logger->pushHandler((new \Monolog\Handler\FirePHPHandler($level)));
                        break;
                    case 'stream':
                        $logger->pushHandler((new \Monolog\Handler\StreamHandler($handler['path'] ?? 'php://stdout', $level)));
                        break;
                    default:
                        throw new \Kuick\App\AppException('Unknown Monolog handler: ' . $type);
                }
            }
            return $logger;
        }, 'Psr\\Log\\LoggerInterface');
    }

    protected function get3()
    {
        return '/var/www/html/tests/Mocks/MockProjectDir/empty';
    }

}
